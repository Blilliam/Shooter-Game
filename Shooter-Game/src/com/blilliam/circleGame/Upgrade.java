package com.blilliam.circleGame;

import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.util.Random;

public class Upgrade {

	GameObject gameObj;

	// =========================
	// UPGRADE BOX DATA
	// =========================
	UpgradeBox[] totalBoxes;
	int[] currBoxIndex = new int[3];

	final int numberOfTotalBoxes = 8;
	final int numberOfcurrBoxes = 3;

	private boolean upgradeChosen = false; // new

	final int rectWidth = 300;
	final int rectHeight = 450;

	int[] costs = { 5, 5, 5, 5, 5, 5, 5, 5 };

	// =========================
	// BUTTONS
	// =========================
	private GameButton exitButton;
	private GameButton rerollButton;

	// =========================
	// CONSTRUCTOR
	// =========================
	public Upgrade(GameObject gameObj) {
		this.gameObj = gameObj;

		// Create upgrade boxes
		totalBoxes = new UpgradeBox[numberOfTotalBoxes];
		for (int i = 0; i < numberOfTotalBoxes; i++) {
			totalBoxes[i] = new UpgradeBox(gameObj, i + 1, 0, 0);
			totalBoxes[i].cost = costs[i];
		}

		// Exit button
		exitButton = new GameButton(AppPanel.WIDTH - 130, 30, 100, 50, "EXIT", () -> {
			GameObject.state = GameState.PLAY; // mark upgrade session as finished
			MouseInput.update();
		});

		// Reroll button
		rerollButton = new GameButton(AppPanel.WIDTH - 180, AppPanel.HEIGHT - 80, 150, 50, "RE-ROLL", () -> {
			if (gameObj.player1.totalUpgradesAvailible > 0) {
				randomCurrBox();
				MouseInput.update();
			}
		});

		randomCurrBox();
	}

	// =========================
	// UPDATE
	// =========================
	public void update() {

	    exitButton.update();
	    rerollButton.update();

	    // Only handle **one click per frame**
	    if (MouseInput.mouseClicked) {

	        boolean didUpgrade = false;

	        // Check exit button first
	        if (exitButton.isHovering()) {
	            upgradeChosen = true;
	            didUpgrade = true; // used to clear click
	        }

	        // Only handle boxes if we havenâ€™t exited
	        if (!didUpgrade) {
	            for (int i = 0; i < numberOfcurrBoxes; i++) {
	                UpgradeBox box = totalBoxes[currBoxIndex[i]];

	                if (box != null && box.isHovering()) {
	                    if (gameObj.player1.totalUpgradesAvailible > 0) {
	                        gameObj.player1.totalUpgradesAvailible--;
	                        box.upgrade();

	                        upgradeChosen = true;
	                        randomCurrBox();
	                        didUpgrade = true;
	                        
	                        gameObj.player1.expToUpgrade *= 1.3;
	                        
	                        break; // stop after first valid box
	                    }
	                }
	            }
	        }

	        // CLEAR mouse click AFTER handling **one action**
	        if (didUpgrade) {
	            MouseInput.mouseClicked = false;
	        }
	    }

	    // Update box animations
	    for (int i = 0; i < numberOfcurrBoxes; i++) {
	        totalBoxes[currBoxIndex[i]].updateAnimation();
	    }
	}


	// =========================
	// DRAW
	// =========================
	public void draw(Graphics2D g2) {

		g2.setFont(new Font("Arial", Font.BOLD, 24));
		FontMetrics fm = g2.getFontMetrics();

		// Background overlay
		g2.setColor(new Color(20, 20, 50, 200));
		g2.fillRect(0, 0, AppPanel.WIDTH, AppPanel.HEIGHT);

		int spacing = (AppPanel.WIDTH - rectWidth * numberOfcurrBoxes) / (numberOfcurrBoxes + 1);
		int y = (AppPanel.HEIGHT - rectHeight) / 2;

		// Title
		g2.setColor(Color.WHITE);
		g2.drawString("UPGRADES", 40, 50);

		// Upgrade boxes
		for (int i = 0; i < numberOfcurrBoxes; i++) {
			UpgradeBox box = totalBoxes[currBoxIndex[i]];
			int x = spacing + i * (rectWidth + spacing);

			box.x = x;
			box.y = y;
			box.w = rectWidth;
			box.h = rectHeight;

			box.draw(g2);
		}

		// Buttons
		exitButton.draw(g2);
		rerollButton.draw(g2);
	}

	// =========================
	// RANDOMIZE BOXES (FIXED)
	// =========================
	public void randomCurrBox() {

		Random rand = new Random();
		boolean[] used = new boolean[numberOfTotalBoxes];

		for (int i = 0; i < numberOfcurrBoxes; i++) {
			int r;
			do {
				r = rand.nextInt(numberOfTotalBoxes);
			} while (used[r]);

			used[r] = true;
			currBoxIndex[i] = r;
			totalBoxes[r].startAnimation();
		}
	}

	public boolean hasFinishedUpgrading() {
		return upgradeChosen || gameObj.player1.totalUpgradesAvailible == 0;
	}

	public void reset() {
		upgradeChosen = false;
	}

}
